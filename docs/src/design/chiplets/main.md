# Chiplets

The Chiplets module contains specialized components dedicated to accelerating complex computations. Each chiplet specializes in executing a specific type of computation and is responsible for proving both the correctness of its computations and its own internal consistency.

Currently, Miden VM relies on 4 chiplets:

- The [Hash Chiplet](./hasher.md) (also referred to as the Hasher), used to compute Rescue Prime Optimized hashes both for sequential hashing and for Merkle tree hashing.
- The [Bitwise Chiplet](./bitwise.md), used to compute bitwise operations (e.g., `AND`, `XOR`) over 32-bit integers.
- The [Memory Chiplet](./memory.md), used to support random-access memory in the VM.
- The [Kernel ROM Chiplet](kernel_rom.md), used to enable executing kernel procedures during the [`SYSCALL` operation](../programs.md#syscall-block).

Each chiplet executes its computations separately from the rest of the VM and proves the internal correctness of its execution trace in a unique way that is specific to the operation(s) it supports. These methods are described by each chiplet’s documentation.

## Chiplets module trace

The execution trace of the Chiplets module is generated by stacking the execution traces of each of its chiplet components. Because each chiplet is expected to generate significantly fewer trace rows than the other VM components (i.e., the decoder, stack, and range checker), stacking them enables the same functionality without adding as many columns to the execution trace.

Each chiplet is identified within the Chiplets module by one or more chiplet selector columns which cause its constraints to be selectively applied.

The result is an execution trace of 18 trace columns, which allows space for the widest chiplet component (the hash chiplet) and a column to select for it.

_**Note**: The following diagram is outdated (see [issue #1829](https://github.com/0xMiden/miden-vm/issues/1829))._

![chiplets](../../assets/design/chiplets/chiplets.png)

During the finalization of the overall execution trace, the chiplets' traces (including internal selectors) are appended to the trace of the Chiplets module one after another, as pictured. Thus, when one chiplet's trace ends, the trace of the next chiplet starts in the subsequent row.

Additionally, a padding segment is added to the end of the Chiplets module's trace so that the number of rows in the table always matches the overall trace length of the other VM processors, regardless of the length of the chiplet traces. The padding will simply contain zeroes.

### Chiplets order

The order in which the chiplets are stacked is determined by the requirements of each chiplet, including the width of its execution trace and the degree of its constraints.

For simplicity, all of the "cyclic" chiplets which operate in multi-row cycles and require starting at particular row increments should come before any non-cyclic chiplets, and these should be ordered from longest-cycle to shortest-cycle. This avoids any additional alignment padding between chiplets.

After that, chiplets are ordered by degree of constraints so that higher-degree chiplets get lower-degree chiplet selector flags.

The resulting order is as follows:

| Chiplet         | Cycle Length | Internal Degree | Chiplet Selector Degree | Total Degree | Columns | Chiplet Selector Flag |
|-----------------|:------------:|:---------------:|:-----------------------:|:------------:|:-------:|-----------------------|
| Hash chiplet    |      8       |        8        |            1            |      9       |   17    | $\{0\}$               |
| Bitwise chiplet |      8       |        3        |            2            |      5       |   13    | $\{1, 0\}$            |
| Memory          |      -       |        6        |            3            |      9       |   12    | $\{1, 1, 0\}$         |
| ACE             |      -       |        5        |            4            |      9       |   16    | $\{1, 1, 1, 0\}$      |
| Kernel ROM      |      -       |        3        |            5            |      8       |    5    | $\{1, 1, 1, 1, 0\}$   |
| Padding         |      -       |        -        |            -            |      -       |    -    | $\{1, 1, 1, 1, 1\}$   |

### Additional requirements for stacking execution traces

Stacking the chiplets introduces one new complexity. Each chiplet proves its own correctness with its own set of internal transition constraints, many of which are enforced between each row in its trace and the next row. As a result, when the chiplets are stacked, transition constraints applied to the final row of one chiplet will cause a conflict with the first row of the following chiplet.

This is true for any transition constraints that are applied at every row and selected by a `Chiplet Selector Flag` for the current row. (Therefore, cyclic transition constraints controlled by periodic columns do not cause any issue.)

This requires the following adjustments for each chiplet.

**In the hash chiplet:** there is no conflict, and therefore no change, since all constraints are periodic.

**In the bitwise chiplet:** there is no conflict, and therefore no change, since all constraints are periodic.

**In the memory chiplet:** all transition constraints cause a conflict. To adjust for this, the selector flag for the memory chiplet is designed to exclude its last row. Thus, memory constraints will not be applied when transitioning from the last row of the memory chiplet to the following row. This is achieved without any additional increase in the degree of constraints by using $s'_2$ as a selector instead of $s_2$ as seen [below](#chiplet-constraints).

**In the ACE chiplet:** some transition constraints must be disabled in the last row. The flags are derived both from the chiplet selectors and are described in the [flags and boundary constraints section](./ace.md#flags-and-boundary-constraints).

**In the kernel ROM chiplet:** the transition constraints referring to the $s_{first}'$ column cause a conflict.
It is resolved by enforcing the initial value of this selector in the last row of the previous chiplet,
and disabling the hash equality constraint in the last row.

## Operation labels

Each operation supported by the chiplets is given a unique identifier to ensure that the requests and responses sent to the [chiplets bus](#chiplets-bus) ($b_{chip}$) are indeed processed by the intended chiplet for that operation and that chiplets which support more than one operation execute the correct one.

The labels are composed from the flag values of the chiplet selector(s) and internal operation selectors (if applicable).
The unique label of the operation is computed as the binary aggregation of the combined selectors plus $1$, note that the combined flag is represented in big-endian, so the bit representation below is reversed.

| Operation              | Chiplet & Internal <br> Selector Flags | Label           | Value |
|------------------------|----------------------------------------|-----------------|-------|
| `HASHER_LINEAR_HASH`   | $\{0 \,\|\, 1, 0, 0\}$                 | `1 + 0b001_0`   | 3     |
| `HASHER_MP_VERIFY`     | $\{0 \,\|\, 1, 0, 1\}$                 | `1 + 0b101_0`   | 11    |
| `HASHER_MR_UPDATE_OLD` | $\{0 \,\|\, 1, 1, 0\}$                 | `1 + 0b011_0`   | 7     |
| `HASHER_MR_UPDATE_NEW` | $\{0 \,\|\, 1, 1, 1\}$                 | `1 + 0b111_0`   | 15    |
| `HASHER_RETURN_HASH`   | $\{0 \,\|\, 0, 0, 0\}$                 | `1 + 0b000_0`   | 1     |
| `HASHER_RETURN_STATE`  | $\{0 \,\|\, 0, 0, 1\}$                 | `1 + 0b100_0`   | 9     |
| `BITWISE_AND`          | $\{1, 0 \,\|\, 0\}$                    | `1 + 0b0_01`    | 2     |
| `BITWISE_XOR`          | $\{1, 0 \,\|\, 1\}$                    | `1 + 0b1_01`    | 6     |
| `MEMORY_WRITE_ELEMENT` | $\{1, 1, 0 \,\|\, 0, 0\}$              | `1 + 0b00_011`  | 4     |
| `MEMORY_WRITE_WORD`    | $\{1, 1, 0 \,\|\, 0, 1\}$              | `1 + 0b10_011`  | 20    |
| `MEMORY_READ_ELEMENT`  | $\{1, 1, 0 \,\|\, 1, 0\}$              | `1 + 0b01_011`  | 12    |
| `MEMORY_READ_WORD`     | $\{1, 1, 0 \,\|\, 1, 1\}$              | `1 + 0b11_011`  | 28    |
| `ACE_INIT`             | $\{1, 1, 1, 0 \,\|\, - \}$             | `1 + 0b_0111`   | 8     |
| `KERNEL_PROC_CALL`     | $\{1, 1, 1, 1, 0 \,\|\, 0\}$           | `1 + 0b0_01111` | 16    |
| `KERNEL_PROC_INIT`     | $\{1, 1, 1, 1, 0 \,\|\, 1\}$           | `1 + 0b1_01111` | 48    |

## Chiplets module constraints

### Chiplet constraints

Each chiplet's internal constraints are defined in the documentation for the individual chiplets. To ensure that constraints are only ever selected for one chiplet at a time, the module's selector columns $s_0, s_1, s_2, s_3, s_4$ are combined into flags. Each chiplet's internal constraints are multiplied by its chiplet selector flag, and the degree of each constraint is correspondingly increased.

This gives the following sets of constraints:

> $$
(1 - s_0) \cdot c_{hash} = 0 \text{ | degree} = 1 + \deg(c_{hash})
$$

> $$
s_0 \cdot (1 - s_1) \cdot c_{bitwise} = 0 \text{ | degree} = 2 + \deg(c_{bitwise})
$$

> $$
s_0 \cdot s_1 \cdot (1 - s'_2) \cdot c_{memory} = 0 \text{ | degree} = 3 + \deg(c_{memory})
$$

> $$
s_0 \cdot s_1 \cdot (s_2) \cdot (1 - s'_3) \cdot c_{ace} = 0 \text{ | degree} = 4 + \deg(c_{ace})
$$

> $$
s_0 \cdot s_1 \cdot (s_2) \cdot (s_3) \cdot (1 - s'_4) \cdot c_{krom} = 0 \text{ | degree} = 5 + \deg(c_{krom})
$$


In the above:

- $c_{hash}, c_{bitwise}, c_{memory}, c_{ace}, c_{krom}$ each represent an internal constraint from the indicated chiplet.
- $\deg(c)$ indicates the degree of the specified constraint.
- flags are applied in a like manner for all internal constraints in each respective chiplet.
- the selector for the memory chiplet excludes the last row of the chiplet (as discussed [above](#additional-requirements-for-stacking-execution-traces)).

### Chiplet selector constraints

We also need to ensure that the chiplet selector columns are set correctly. Although there are three columns for chiplet selectors, the stacked trace design means that they do not all act as selectors for the entire trace. Thus, selector constraints should only be applied to selector columns when they are acting as selectors.

- $s_0$ acts as a selector for the entire trace.
- $s_1$ acts as a selector column when $s_0 = 1$.
- $s_2$ acts as a selector column when $s_0 = 1$ and $s_1 = 1$.
- $s_3$ acts as a selector column when $s_0 = 1$, $s_1 = 1$, and $s_2 = 1$.
- $s_4$ acts as a selector column when $s_0 = 1$, $s_1 = 1$, $s_2 = 1$, and $s_3 = 1$.

Two conditions must be enforced for columns acting as chiplet selectors.

1. When acting as a selector, the value in the selector column must be binary.
2. When acting as a selector, the value in the selector column may only change from $0 \rightarrow 1$.

The following constraints ensure that selector values are binary.

> $$
s_0^2 - s_0 = 0 \text{ | degree} = 2 \\
s_0 \cdot (s_1^2 - s_1) = 0 \text{ | degree} = 3 \\
s_0 \cdot s_1 \cdot (s_2^2 - s_2) = 0 \text{ | degree} = 4
s_0 \cdot s_1 \cdot s_2 \cdot (s_3^2 - s_3) = 0 \text{ | degree} = 5
s_0 \cdot s_1 \cdot s_2 \cdot s_3 \cdot (s_4^2 - s_4) = 0 \text{ | degree} = 6
$$

The following constraints ensure that the chiplets are stacked correctly by restricting selector values so they can only change from $0 \rightarrow 1$.

> $$
s_0 \cdot (s_0 - s'_0) = 0 \text{ | degree} = 2 \\
s_0 \cdot s_1 \cdot (s_1 - s'_1) \text{ | degree} = 3 \\
s_0 \cdot s_1 \cdot s_2 \cdot (s_2 - s'_2) \text{ | degree} = 4 \\
s_0 \cdot s_1 \cdot s_2 \cdot s_3 \cdot (s_3 - s'_3) \text{ | degree} = 5 \\
s_0 \cdot s_1 \cdot s_2 \cdot s_3 \cdot s_4 \cdot (s_4 - s'_4) \text{ | degree} = 6 \\
$$

In other words, the above constraints enforce that if a selector is $0$ in the current row, then it must be either $0$ or $1$ in the next row; if it is $1$ in the current row, it must be $1$ in the next row.

## Chiplets bus

The chiplets must be explicitly connected to the rest of the VM in order for it to use their operations. This connection must prove that all specialized operations which a given VM component claimed to offload to one of the chiplets were in fact executed by the correct chiplet with the same set of inputs and outputs as those used by the offloading component.

This is achieved via a [bus](../lookups/main.md#communication-buses-in-miden-vm) called $b_{chip}$ where a request can be sent to any chiplet and a corresponding response will be sent back by that chiplet.

The bus is implemented as a single [running product column](../lookups/multiset.md) where:

- Each request is “sent” by computing an operation-specific lookup value from an [operation-specific label](#operation-labels), the operation inputs, and the operation outputs, and then dividing it out of the $b_{chip}$ running product column.
- Each chiplet response is “sent” by computing the same operation-specific lookup value from the label, inputs, and outputs, and then multiplying it into the $b_{chip}$ running product column.

Thus, if the requests and responses match, then the bus column $b_{chip}$ will start and end with the value $1$. This condition is enforced by boundary constraints on the $b_{chip}$ column.
It is also possible to invoke chiplet computations through public inputs, by initializing the bus with requests that must be responded to by the chiplets.
In this case, the verifier computes the product of all randomness-reduced requests, treating it as a constant when evaluating the boundary constraint for the initial value of the bus column.
Currently, this is only used to request the initialization of kernel procedure digests for the kernel ROM chiplet.

Note that the order of the requests and responses does not matter, as long as they are all included in $b_{chip}$. In fact, requests and responses for the same operation will generally occur at different cycles.

### Chiplets bus constraints

The chiplets bus constraints are defined by the components that use it to communicate.

Lookup requests are sent to the chiplets bus by the following components:

- The stack sends requests for [bitwise](../stack/u32_ops.md#u32and), [memory](../stack/io_ops.md#memory-access-operations), and [cryptographic hash operations](../stack/crypto_ops.md).
- The decoder sends requests for [hash operations](../decoder/main.md#program-block-hashing) for program block hashing.
- The decoder sends a procedure access request to the [Kernel ROM chiplet](./kernel_rom.md) for each `SYSCALL` during [program block hashing](../decoder/main.md#program-block-hashing).
- The verifier initializes the bus with requests to the [Kernel ROM chiplet](./kernel_rom.md) for each unique kernel procedure digest.

Responses are provided by the [hash](./hasher.md#chiplets-bus-constraints), [bitwise](./bitwise.md#chiplets-bus-constraints), [memory](./memory.md#chiplets-bus-constraints), and [kernel ROM](./kernel_rom.md#chiplets-bus-constraints) chiplets.

The chiplet bus can be initialized with randomness-reduced requests $v_0, v_1, \ldots$ by computing their product $v_{init} = \prod_i v_i$, and enforcing the boundary constraint in the first row to ensure
$b_{chip} = \frac{1}{v_{init}}$.
Note that $v_{init}$ is a constant, and therefore does not contribute to the constraint degree.

> $$
b_{chip} \cdot v_{init} - 1 = 0 \text{ | degree} = 1
$$

## Chiplets virtual table

_Note: over time, the use of this construction has evolved to the point where its name doesn't match the way it is used. This is documented in [issue #1779](https://github.com/0xMiden/miden-vm/issues/1779)._

The [virtual table](../lookups/multiset.md#virtual-tables) bus $vt_{chip}$ is used by several chiplets as a way to maintain and enforce the correctness of their internal states, and enable communication with each other.

The hasher chiplet uses it as a way to store [sibling nodes](./hasher.md#sibling-table-constraints) when performing a Merkle tree update.
In particular, it expects an empty bus at the start of this operation, and ensures that all entries it inserts are removed once the new tree is finalized.
Consequently, the column representing this table must be equal to 1 at the boundaries of the hasher chiplet's trace, preventing communication with other chiplets.

Other chiplets use the table as an extension of the chiplet bus, since both multi-sets are merged in the last row of the overall trace.

This enables chiplets to make bus requests to other chiplets, without affecting the degree of the chiplet bus.
As currently implemented, a single constraint is required to include all requests made by the main trace and corresponding responses from the chiplets.
The degree of this constraint is the maximum of both message types and is currently reached by the requests by the main trace,
preventing chiplets from performing any requests using the same bus.
Instead, a chiplet can make a request through the $vt_{chip}$ bus, with the receiving chiplet responding through the main chiplet bus $b_{chip}$.

At the moment, this feature is only used by the [ACE](./ace.md#bus-messages) allowing it to read inputs and circuit instructions stored in the memory chiplet.
Note that the [memory](./memory.md#chiplets-bus-constraints) chiplet responds via the chiplet bus $b_{chip}$.

To combine these correctly, the [running product column](../lookups/multiset.md) for this table must be constrained not only at the beginning and the end of the trace, but also where the hash chiplet ends.

### Chiplets virtual table constraints

Although the [hasher chiplet](./hasher.md#sibling-table-constraints) ensures the sibling table is empty between any Merkle tree update computation,
we must also enforce this property at the boundary of the chiplet itself.
Using the hasher chiplet's selector $s_0$, the following constraint ensures the bus equals one whenever $s_0$ transitions.

> $$
(s'_0 - s_0) \cdot (1 - vt_{chip}) = 0 \text{ | degree} = 2
$$

To connect the chiplet virtual table and the bus, we enforce the following constraint in the last row, ensuring the product of both their running products is 1.

> $$
vt_{chip} \cdot b_{chip} - 1 = 0 \text{ | degree} = 2.
$$

## Chiplet logUp bus

An auxiliary [logUp bus](../lookups/logup.md) is available to chiplets, though it is currently only used by the [ACE chiplet](./ace.md#wire-bus) to check the wiring of the arithmetic circuit being evaluated. We refer to that chiplet's documentation for constraint applied to the corresponding auxiliary column.

Since this column could later be used by other chiplets, we require boundary constraints over the entire chiplet trace to constrain the running sum to be zero in the first and final row of the auxiliary column.