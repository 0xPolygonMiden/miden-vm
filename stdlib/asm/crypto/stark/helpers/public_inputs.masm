use.std::crypto::stark::constants

# CONSTANTS
# =================================================================================================

# Number of fixed length public inputs with padding (in field elements)
# This is composed of the input/output operand stacks (16 * 2) and the program digest (4) and four
# zeros for padding to the next multiple of 4. Note that, then, the fixed length public inputs
# which are stored as extension field elements will be double-word aligned. 
const.NUM_FIXED_LEN_PUBLIC_INPUTS=40

# Op label for kernel procedures table messages
const.KERNEL_OP_LABEL=48

# CONSTANTS GETTERS
# =================================================================================================

export.get_num_fixed_len_public_inputs
    push.NUM_FIXED_LEN_PUBLIC_INPUTS
end

export.kernel_proc_table_op_label
    push.KERNEL_OP_LABEL
end

# HELPER PROCEDURES
# =================================================================================================

#! Reduce each group of the variable-length public inputs and stores the result in memory.
#!
#! Input: [next_var_len_pub_inputs_ptr, var_len_pub_inputs_res_ptr, ...]
#! Output:  [next_var_len_pub_inputs_ptr, var_len_pub_inputs_res_ptr, ...]
export.reduce_var_len_public_inputs_groups
    # 1) Reduce kernel procedure digests and store them.
    adv_push.1
    # => [num_ker_procedures, next_var_len_pub_inputs_ptr, var_len_pub_inputs_res_ptr, ...]
    exec.reduce_kernel_digests
    # => [next_var_len_pub_inputs_ptr, var_len_pub_inputs_res_ptr, ...]
end

#! Reduces the kernel procedures digests using auxiliary randomness.
#!
#! Input: [num_ker_procedures, digests_ptr, ...]
#! Output: [res1, res0, next_ptr, ...]
#!
#! where:
#!  1. `digests_ptr` is a pointer to the kernel procedures digests, and
#!  2. `res = (res0, res1)` is the resulting reduced value.
proc.reduce_kernel_digests
    # Assert that the number of kernel procedures is at most 1023
    dup u32lt.1024 assert

    # Store number of kernel procedures digests
    push.0.0 dup.2
    exec.constants::tmp1 mem_storew
    # => [num_ker_procedures, 0, 0, num_ker_procedures, digests_ptr, ...]

    # Load alpha
    exec.constants::aux_rand_nd_ptr mem_loadw
    # => [alpha1, alpha0, beta1, beta0, digests_ptr, ...]

    # We will keep [beta0, beta1, alpha0 + op_label, alpha1] on the stack so that we can compute
    # the final result, where op_label is a unique label to domain separate the interaction with
    # the chiplets` bus.
    # The final result is then computed as:
    #
    #   alpha + op_label * beta^0 + beta * (r_0 * beta^0 + r_1 * beta^1 + r_2 * beta^2 + r_3 * beta^3)
    swap
    exec.kernel_proc_table_op_label
    add
    swap
    # => [alpha1, alpha0 + op_label, beta1, beta0, digests_ptr, ...]

    # Push the `horner_eval_ext` accumulator
    push.0.0
    # => [acc1, acc0, alpha1, alpha0 + op_label, beta1, beta0, digests_ptr, ...]

    # Push the pointer to the evaluation point beta
    exec.constants::aux_rand_nd_ptr
    # => [beta_ptr, acc1, acc0, alpha1, alpha0 + op_label, beta1, beta0,  digests_ptr, ...]

    # Get the pointer to kernel procedures digests
    movup.7
    # => [digests_ptr, beta_ptr, acc1, acc0, alpha1, alpha0 + op_label, beta1, beta0,  ...]

    # Set up the stack for `mem_stream` + `horner_eval_ext`
    swapw
    padw padw
    # => [Y, Y, alpha1, alpha0 + op_label, beta1, beta0,  digests_ptr, beta_ptr, acc1, acc0, ...]
    # where `Y` is a garbage word.

    exec.constants::tmp1 mem_loadw dup
    push.0
    neq

    while.true
        repeat.1
            mem_stream
            horner_eval_base
        end
        # => [Y, Y, alpha1, alpha0 + op_label, beta1, beta0, digests_ptr, beta_ptr, acc1, acc0, ...]

        swapdw
        # => [alpha1, alpha0 + op_label, beta1, beta0, digests_ptr, beta_ptr, acc1, acc0, Y, Y, ...]

        movup.7 movup.7
        # => [acc1, acc0, alpha1, alpha0 + op_label, beta1, beta0, digests_ptr, beta_ptr, Y, Y, ...]
        
        dup.5 dup.5
        # => [beta1, beta0, acc1, acc0, alpha1, alpha0 + op_label, beta1, beta0, digests_ptr, beta_ptr, Y, Y, ...]
        ext2mul
        # => [tmp1', tmp0', alpha1, alpha0 + op_label, beta1, beta0, digests_ptr, beta_ptr, Y, Y, ...]

        dup.3 dup.3
        ext2add
        # => [term1', term0', alpha1, alpha0 + op_label, beta1, beta0, digests_ptr, beta_ptr, Y, Y, ...]
  
        movdn.15
        movdn.15
        # => [alpha1, alpha0 + op_label, beta1, beta0, digests_ptr, beta_ptr, Y, Y, term1', term0', ...]

        push.0 movdn.6
        push.0 movdn.6
        # => [alpha1, alpha0 + op_label, beta1, beta0, digests_ptr, beta_ptr, 0, 0, Y, Y, term1', term0', ...]
 
        swapdw
        # => [Y, Y, alpha1, alpha0 + op_label, beta1, beta0, digests_ptr, beta_ptr, 0, 0, term1', term0', ...]

        exec.constants::tmp1 mem_loadw sub.1
        exec.constants::tmp1 mem_storew
 
        dup
        push.0
        neq
    end
    # => [Y, Y, alpha1, alpha0 + op_label, beta1, beta0, digests_ptr, beta_ptr, 0, 0, term1', term0', ...]
    dropw dropw dropw
    # => [digests_ptr, beta_ptr, 0, 0, term1', term0', ...]
    dup exec.constants::tmp2 mem_store
    exec.constants::tmp1 mem_loadw drop drop drop

    push.1.0
    movup.2
    dup
    push.0
    neq
    # => [loop, n, acc1, acc0, term1_1, term1_0, ..., termn_1, termn_0, ...]

    while.true
        sub.1 movdn.4
        # => [acc1, acc0, term1_1, term1_0, n - 1, ..., termn_1, termn_0, ...]
        ext2mul
        # => [acc1', acc0', n - 1, ..., termn_1, termn_0, ...]
        movup.2
        dup
        push.0
        neq
        # => [loop, n - 1, acc1', acc0', term1_1, term1_0, ..., termn_1, termn_0, ...]
    end

    drop
    exec.constants::tmp2 mem_load movdn.2
    # => [prod_acc1, prod_acc0, digests_ptr, ...]

    # Store the result
    push.0.0
    # => [0, 0, prod_acc1, prod_acc0, digests_ptr, var_len_pub_inputs_res_ptr, ...]
    dup.5 add.4 swap.6
    mem_storew
    dropw
    # => [digests_ptr, var_len_pub_inputs_res_ptr, ...]
end
