use.std::math::ext2

#! Given a stack in the following initial configuration [a1, a0, b1, b0, c1, c0, d1, d0, ...] the following
#! procedure computes (a + b + ((a - b) * c * d^(-1)))/2 with the assumption that d1 is equal to 0
export.fold_2
    dupw                #[a1, a0, b1, b0, a1, a0, b1, b0, c1, c0, d1, d0, ...]
    exec.ext2::sub      #[(a-b)1, (a-b)0, a1, a0, b1, b0, c1, c0, d1, d0, ...]
    push.0.0            #[0, 0, (a-b)1, (a-b)0, a1, a0, b1, b0, c1, c0, d1, d0, ...]
    movupw.2            #[c1, c0, d1, d0, 0, 0, (a-b)1, (a-b)0, a1, a0, b1, b0, ...]
    movup.2             #[d1, c1, c0, d0, 0, 0, (a-b)1, (a-b)0, a1, a0, b1, b0, ...]
    drop                #[c1, c0, d0, 0, 0, (a-b)1, (a-b)0, a1, a0, b1, b0, ...]
    movup.2             #[d0, c1, c0, 0, 0, (a-b)1, (a-b)0, a1, a0, b1, b0, ...]
    inv                 #[d0_inv, c1, c0, 0, 0, (a-b)1, (a-b)0, a1, a0, b1, b0, ...]
    exec.ext2::mul_base       #[y1, y0, 0, 0, (a-b)1, (a-b)0, a1, a0, b1, b0, ...]
    movup.2             #[0, y1, y0, 0, (a-b)1, (a-b)0, a1, a0, b1, b0, ...]
    movup.3             #[0, 0, y1, y0, (a-b)1, (a-b)0, a1, a0, b1, b0, ...]
    drop                #[0, y1, y0, (a-b)1, (a-b)0, a1, a0, b1, b0, ...]
    drop                #[y1, y0, (a-b)1, (a-b)0, a1, a0, b1, b0, ...]
    exec.ext2::mul      #[w1, w0, a1, a0, b1, b0, ...]
    exec.ext2::add      #[v1, v0, b1, b0, ...]
    exec.ext2::add      #[o1, o0, ...]
    push.9223372034707292161 #[2_inv, o1, o0]
    exec.ext2::mul_base
end

#! This procedure computes the folded position in the exponent of the corresponding domain generator
#! normalized by the offset. It uses an algebraic relationship between the original and folded positions
#! given by multiplication with the 2nd primitive root of unity in our field.
#! input:    #[?, poe, poe, ...]
#! output:   #[poe_sq, xs, ...]
export.next_pos_exp
    dup.1                               #[poe, ?, poe, poe, ...]   
    push.18446744069414584320           #[nor, poe, ?, poe, poe, ...]
    mul                                 #[poe/nor, ?, poe, poe, ...]
    swap                                #[?, poe/nor, poe, poe, ...]
    cdrop                               #[xs, poe, ...]
    mul.7                               #mul by offset 
    swap                                #[poe, xs, ...]
    dup mul                             #[poe_sq, xs, ...]
end

#! Preprocess the layer commitments C as well as num_q (number of queries), d (initial domain size), 
#! g (intial domain generator), t_d (initial tree depth) and (a0, a1) (the folding challenges alpha).
#! The address of the word (num_q, d, g, t_d) will be at locaddr.0. The commitments and alphas will be
#! at the subsequent addresses. The total number of such commitments and alphas is t_d - 3 
#! (excluding the remainder commitment).
export.preprocess.2
    locaddr.1                   #[add, ..]
    adv_push.4                  #[num_q, d, g, t_d, add, ..]
    dup.3                       #[t_d, num_q, d, g, t_d, add, ..]
    movdn.4                     #[num_q, d, g, t_d, t_d, add, ..]
    dup.5                       #[add, num_q, d, g, t_d, t_d, add, ..]
    mem_storew dropw            #[t_d, add, ..]
    dup
    u32checked_neq.3            #[?, t_d, add, ..]
    while.true
        push.0.0.0.0
        adv_loadw                       #[C, t_d, add, ..]
        movup.5                         #[add, C, t_d, ..]
        u32wrapping_add.1               #[add+1, C, t_d, ..]
        dup movdn.6                     #[add+1, C, t_d, add+1, ..]
        mem_storew                      #[C, t_d, add+1, ..]
        adv_loadw                       #[0, 0, a1, a0, t_d, add+1, ..]
        movup.5                         #[add+1, 0, 0, a1, a0, t_d, ..]
        u32wrapping_add.1               #[add+2, 0, 0, a1, a0, t_d, ..]
        dup movdn.6                     #[add+2, 0, 0, a1, a0, t_d, add+2, ..]
        mem_storew dropw                #[t_d, add+2, ..]
        u32wrapping_sub.1 dup           #[t_d-1, t_d-1, add+2, ..]
        u32checked_neq.3                #[?, t_d-1, add+2, ..]
    end
    #[0, add, ..]
    drop 
    add.1               # this address will be used for the adv_pipe instruction
    # value of the remainder codeword
    adv_push.2
    movup.2

    push.0.0.0.0
    locaddr.1
    mem_loadw
    locaddr.1
end

#! Helper procedure used to prepare the stack for the next iteration of verify_query_layer for a 
#! positon p. (add' - 2) is the address of the commitment for the next layer and (add' - 1) is 
#! the address of the next alpha folding challenge.
#! Input: [t_d, e1, e0, p, d, poe, add', ..]
#! Output: [d, p, C, t_d, e1, e0, poe, a1, a0, add'-2, ..]
export.prepare_next
    movup.6                                 #[add', t_d, e1, e0, p, d, poe, ..] where add' points to the address of the previous C
    sub.2 dup                               #[add'-2, add'-2, t_d, e1, e0, p, d, poe, ..] add' - 2 now points to the new C
    movdn.7                                 #[add'-2, t_d, e1, e0, p, d, poe, add'-2, ..]
    push.0.0.0.0                            #[0, 0, 0, 0, add'-2, t_d, e1, e0, p, d, poe, add'-2, ..]
    dup.4 add.1                             #[add'-1, 0, 0, 0, 0, add'-2, t_d, e1, e0, p, d, poe, add'-2, ..]
    mem_loadw                               #[0, 0, a1, a0, add'-2, t_d, e1, e0, p, d, poe, add'-2, ..]
    push.0.0                                #[0, 0, 0, 0, a1, a0, add'-2, t_d, e1, e0, p, d, poe, add'-2, ..]
    movup.6                                 #[add'-2, 0, 0, 0, 0, a1, a0, t_d, e1, e0, p, d, poe, add'-2, ..]
    mem_loadw                               #[C, a1, a0, t_d, e1, e0, p, d, poe, add'-2, ..]
    swapw.2                                 #[e0, p, d, poe, a1, a0, t_d, e1, C, add'-2, ..]
    swap.2                                  #[d, p, e0, poe, a1, a0, t_d, e1, C, add'-2, ..]
    movup.7                                 #[e1, d, p, e0, poe, a1, a0, t_d, C, add'-2, ..]
    movup.7                                 #[t_d, e1, d, p, e0, poe, a1, a0, C, add'-2, ..]
    movupw.2                                #[C, t_d, e1, d, p, e0, poe, a1, a0, add'-2, ..]
    movup.7                                 #[p, C, t_d, e1, d, e0, poe, a1, a0, add'-2, ..]
    movup.7                                 #[d, p, C, t_d, e1, e0, poe, a1, a0, add'-2, ..]
end

#! The following procedure computes an iteration of FRI verification for a query.
#! The stack starts in the following initial configuration [d, p, C, t_d, e1, e0, poe, a1, a0, ..] where d is 
#! the current domain size, p the current position, C is the commitment of current layer, t_d 
#! its corresponding tree depth, (e1, e0) is the evaluation point, poe is the position in the exponent
#! of the domain generator, (a1, a0) is the alpha to compute the next evaluation point.
#! TODO: Check where/if some checks are needed at the beginning, like p < d (p&d are u32) and that 2^t_d == d 
#! Input: #[d, p, C, t_d, e1, e0, poe, a1, a0, add', add_f..]
#! Output: #[t_d-1, e1, e0, p%d/2, d/2, poe_sq, add', add_f..]
export.verify_query_layer.1
    u32unchecked_div.2          #[d/2, p, C, t_d, ...]
    dup                         #[d/2, d/2, p, C, t_d, ...]
    dup.2 swap                  #[d/2, p, d/2, p, C, t_d, ...]
    u32checked_divmod           #[p%d/2, ?, d/2, p, C, t_d, ...]
    swapw                       #[C, p%d/2, ?, d/2, p, t_d, ...]
    dup.4                       #[p%d/2, C, p%d/2, ?, d/2, p, t_d, ...]
    dup.9                       #[t_d, p%d/2, C, p%d/2, ?, d/2, p, t_d, ...]
    mtree_get  swapw            #[C, V', p%d/2, ?, d/2, p, t_d, ...]  V' are the digest of values V = (v3, v2, v1, v0)
    dropw

    # Unhashing the leaf values
    push.4.0.0.0.0.0.0.0
    adv_loadw
    loc_storew.0
    push.0.0.0.0
    rpperm
    swapw.3
    movup.4
    assert_eq
    movup.3
    assert_eq
    movup.2
    assert_eq
    assert_eq
    dropw
    loc_loadw.0

    # Check that evaluation (from the previous layer) is equal to the (appropriate) unhashed values.
    # The hash values to compare against are selected using the binary value ?.
    dupw  movdnw.2              #[v3, v2, v1, v0, p%d/2, ?, d/2, p, V, t_d, ...]
    movup.2 swap                #[v3, v1, v2, v0, p%d/2, ?, d/2, p, V, t_d, ...]
    dup.5                       #[?, v3, v1, v2, v0, p%d/2, ?, d/2, p, V, t_d, ...]
    cdrop                       #[v1, v2, v0, p%d/2, ?, d/2, p, V, t_d, ...]
    movdn.2                     #[v2, v0, v1, p%d/2, ?, d/2, p, V, t_d, ...]
    dup.4                       #[?, v2, v0, v1, p%d/2, ?, d/2, p, V, t_d, ...]
    cdrop   swap                #[v1, v0, p%d/2, ?, d/2, p, V, t_d, e1, e0, ...]
    dup                         #[v1, v1, v0, p%d/2, ?, d/2, p, V, t_d, e1, e0..]
    movup.12                    #[e1, v1, v1, v0, p%d/2, ?, d/2, p, t_d, e0..]
    assert_eq                   #[v1, v0, p%d/2, ?, d/2, p, V, t_d, e0..]
    dup.1                       #[v0, v1, v0, p%d/2, ?, d/2, p, V, t_d, e0..]
    movup.12                    #[e0, v0, v1, v0, p%d/2, ?, d/2, p, V, t_d..]
    assert_eq                   #[v1, v0, p%d/2, ?, d/2, p, V, t_d, poe, ..] #poe is position in the exponent

    # Prepare for fold_2 procedure by computing: offset * (domain_generator ^ position). This is done
    # using poe from the previous layer and the binary value ? using the next_pos_exp procedure.
    drop drop swapw             #[V, p%d/2, ?, d/2, p, t_d, poe, ..]
    movup.9                     #[poe, V, p%d/2, ?, d/2, p, t_d, ..]
    dup                         #[poe, poe, V, p%d/2, ?, d/2, p, t_d, ..]
    movup.7                     #[?, poe, poe, V, p%d/2, d/2, p, t_d, ..]
    exec.next_pos_exp           #[poe_sq, xs, V, p%d/2, d/2, p, t_d, ..]
    swap.8 drop                 #[xs, V, p%d/2, d/2, poe_sq, t_d, ..]
    push.0                      #[0, xs, V, p%d/2, d/2, poe_sq, t_d, a1, a0, ..]
    movup.11 movup.11           #[a1, a0, 0, xs, v3, v2, v1, v0, p%d/2, d/2, poe_sq, t_d, ..]   
    swapw                       #[v3, v2, v1, v0, a1, a0, 0, xs, p%d/2, d/2, poe_sq, t_d, ..] #Should simplify fri since d1 is always equal to zero
    movup.3 movup.3
    exec.fold_2                 #[e1, e0, p%d/2, d/2, poe_sq, t_d, ..]

    # Decrement the depth i.e. move one layer deeper in the folding step of FRI verification.
    movup.5 u32wrapping_sub.1   #[t_d-1, e1, e0, p%d/2, d/2, poe_sq, add', ..]
    

end

#! Verify a single query. The expected stack configuration is [add, num_q, d, g, t_d, add', ...]
#! where add is the address storing the current (num_q, d, g, t_d), num_q is the index of the current query, 
#! d is the domain size of the LDE, g is its generator and add' is the address of the commitment to 
#! the first layer with the commitments to subsequent layers laid out, in alternating order with the layer
#! alphas, in the subsequent addresses i.e. add' - 2, add' - 1 ...
#! Input:  #[d, p, C, t_d, e1, e0, poe, a1, a0, add_f - 2, add_f, add_i, ...]
#! Output: #[p%d/2, d/2, poe_sq, add_i + 1, add_f, add_i, rem1, rem0...]
export.verify_query
    exec.verify_query_layer
    #[t_d-1, e1, e0, p%d/2, d/2, poe_sq, add', ..]

    dup u32checked_neq.3
    while.true
        exec.prepare_next
        exec.verify_query_layer
        dup u32checked_neq.3
    end

    ## Verify remainder 
    drop
    dup.8 assert_eq
    dup.8 assert_eq
end

#! Verify that the hash of the remainder codeword is equal to the commitment provided by the prover
#! The following implementation relies on the assumption that the blowup factor is 8 and that the degree
#! of the remainder is zero.
#! Input: #[p%d/2, d/2, poe_sq, add_i + 1, add_f, add_i, rem1, rem0...]
#! Output: ()
export.verify_remainder_com
    dropw                  #[r1, r0, ..]
    drop drop
    dup.1 dup.1
    push.4.0.0.0
    swapw
    push.0.0.0.0

    # compute the leaf
    rpperm
    dropw swapw dropw

    # compute the Merkle tree root
    dupw rphash     
    dupw rphash
    push.0.0.0.0
    adv_loadw
    eqw
    assert
    dropw dropw
end

#! This procedure verifies a FRI proof with number of queries num_q, initial domain size d, generator
#! for this domain g, and tree depth of the initial layer Merkle tree commitment. add_i points to
#! the address containing values common to all queries as well as to keep track of the queries
#! that remain to be verified. add_f points to the address that will contain the result of adv_pipe.
#! add_f - 2 * i - 2 points to the layer folding challenges alpha and add_f - 2 * i - 1 points to
#! the i-th layer commitment.
#! Input: #[add_i, num_q, d, g, t_d, add_f, ...]
#! Output: ()
export.verify_fri
    push.1
    while.true
        dup                         #[add_i, add_i, num_q, d, g, t_d, add_f, ...]
        movdn.6                     #[add_i, num_q, d, g, t_d, add_f, add_i, ...]
        mem_storew                  #[num_q, d, g, t_d, ...]
        push.0.0.0
        adv_loadw                   #[0, p, e1, e0, d, g, t_d, ...]
        drop                        #[p, e1, e0, d, g, t_d, ...]
        dup                         #[p, p, e1, e0, d, g, t_d, ...]
        movup.5                     #[g, p, p, e1, e0, d, t_d, ...]
        swap                        #[p, g, p, e1, e0, d, t_d, ...]
        exp.u32                     #[poe, p, e1, e0, d, t_d, ...]
        dup.6                       #[add_f, poe, p, e1, e0, d, t_d, add_f, ...]
        sub.2 dup                   #[add_f - 2, add_f - 2, poe, p, e1, e0, d, t_d, add_f, ...]
        movdn.7                     #[add_f - 2, poe, p, e1, e0, d, t_d, add_f - 2, add_f, ...]
        push.0.0.0.0                #[0, 0, 0, 0, add_f - 2, poe, p, e1, e0, d, t_d, add_f - 2, ...]
        dup.4  add.1                #[add_f - 1, 0, 0, 0, 0, add_f - 2, poe, p, e1, e0, d, t_d, add_f - 2, ...]
        mem_loadw                   #[0, 0, a1, a0, add_f - 2, poe, p, e1, e0, d, t_d, add_f - 2, ...]
        push.0.0                    #[0, 0, 0, 0, a1, a0, add_f - 2, poe, p, e1, e0, d, t_d, add_f - 2, ...]
        movup.6                     #[add_f - 2, 0, 0, 0, 0, a1, a0, poe, p, e1, e0, d, t_d, add_f - 2, ...]
        mem_loadw                   #[C, a1, a0, poe, p, e1, e0, d, t_d, add_f - 2, ...]

        
        swapw.2 swapw           #[a1, a0, poe, p, e1, e0, d, t_d, C, add_f - 2, ...]
        movup.2                 #[poe, a1, a0, p, e1, e0, d, t_d, C, add_f - 2, ...]
        movup.5                 #[e0, poe, a1, a0, p, e1, d, t_d, C, add_f - 2, ...]
        swapw                   #[p, e1, d, t_d, e0, poe, a1, a0, C, add_f - 2, ...]
        movupw.2                #[C, p, e1, d, t_d, e0, poe, a1, a0, add_f - 2, ...]
        movup.4                 #[p, C, e1, d, t_d, e0, poe, a1, a0, add_f - 2, ...]
        movup.6                 #[d, p, C, e1, t_d, e0, poe, a1, a0, add_f - 2, ...]
        movup.6                 #[e1, d, p, C, t_d, e0, poe, a1, a0, add_f - 2, ...]
        movdn.7                 #[d, p, C, t_d, e1, e0, poe, a1, a0, add_f - 2, add_f, add_i, ...]

        ## Prepare initial is done for query p
        # Call verify query full by iterating verify query layer 
        exec.verify_query

        ## Prepare for next iteration of while loop
        #[p%d/2, d/2, poe_sq, add_i + 1, add_f, add_i, rem1, rem0...]
        dup.5                  #[add_i, p%d/2, d/2, poe_sq, add_i + 1, add_f, add_i, rem1, rem0...]
        mem_loadw
        sub.1 
        dup
        neq.0                  #[?, num_q-1, d, g, t_d, add_f, add_i, rem1, rem0, ...]
        movup.6 swap           #[?, add_i, num_q-1, d, g, t_d, add_f, rem1, rem0, ...]
    end

    exec.verify_remainder_com
end