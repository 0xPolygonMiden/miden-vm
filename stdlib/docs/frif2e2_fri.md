
## std::crypto::fri::frif2e2
| Procedure | Description |
| ----------- | ------------- |
| fold_2 | Given a stack in the following initial configuration [a1, a0, b1, b0, c1, c0, d1, d0, ...] the following<br /><br />procedure computes (a + b + ((a - b) * c * d^(-1)))/2 with the assumption that d1 is equal to 0 |
| next_pos_exp | This procedure computes the folded position in the exponent of the corresponding domain generator<br /><br />normalized by the offset. It uses an algebraic relationship between the original and folded positions<br /><br />given by multiplication with the 2nd primitive root of unity in our field.<br /><br />input:    #[?, poe, poe, ...]<br /><br />output:   #[poe_sq, xs, ...] |
| preprocess | Preprocess the layer commitments C as well as num_q (number of queries), d (initial domain size),<br /><br />g (intial domain generator), t_d (initial tree depth) and (a0, a1) (the folding challenges alpha).<br /><br />The address of the word (num_q, d, g, t_d) will be at locaddr.0. The commitments and alphas will be<br /><br />at the subsequent addresses. The total number of such commitments and alphas is t_d - 3<br /><br />(excluding the remainder commitment). |
| prepare_next | Helper procedure used to prepare the stack for the next iteration of verify_query_layer for a<br /><br />positon p. (add' - 2) is the address of the commitment for the next layer and (add' - 1) is<br /><br />the address of the next alpha folding challenge.<br /><br />Input: [t_d, e1, e0, p, d, poe, add', ..]<br /><br />Output: [d, p, C, t_d, e1, e0, poe, a1, a0, add'-2, ..] |
| verify_query_layer | The following procedure computes an iteration of FRI verification for a query.<br /><br />The stack starts in the following initial configuration [d, p, C, t_d, e1, e0, poe, a1, a0, ..] where d is<br /><br />the current domain size, p the current position, C is the commitment of current layer, t_d<br /><br />its corresponding tree depth, (e1, e0) is the evaluation point, poe is the position in the exponent<br /><br />of the domain generator, (a1, a0) is the alpha to compute the next evaluation point.<br /><br />TODO: Check where/if some checks are needed at the beginning, like p < d (p&d are u32) and that 2^t_d == d<br /><br />Input: #[d, p, C, t_d, e1, e0, poe, a1, a0, add', add_f..]<br /><br />Output: #[t_d-1, e1, e0, p%d/2, d/2, poe_sq, add', add_f..] |
| verify_query | Verify a single query. The expected stack configuration is [add, num_q, d, g, t_d, add', ...]<br /><br />where add is the address storing the current (num_q, d, g, t_d), num_q is the index of the current query,<br /><br />d is the domain size of the LDE, g is its generator and add' is the address of the commitment to<br /><br />the first layer with the commitments to subsequent layers laid out, in alternating order with the layer<br /><br />alphas, in the subsequent addresses i.e. add' - 2, add' - 1 ...<br /><br />Input:  #[d, p, C, t_d, e1, e0, poe, a1, a0, add_f - 2, add_f, add_i, ...]<br /><br />Output: #[p%d/2, d/2, poe_sq, add_i + 1, add_f, add_i, rem1, rem0...] |
| verify_remainder_com | Verify that the hash of the remainder codeword is equal to the commitment provided by the prover<br /><br />The following implementation relies on the assumption that the blowup factor is 8 and that the degree<br /><br />of the remainder is zero.<br /><br />Input: #[p%d/2, d/2, poe_sq, add_i + 1, add_f, add_i, rem1, rem0...]<br /><br />Output: () |
| verify_fri | This procedure verifies a FRI proof with number of queries num_q, initial domain size d, generator<br /><br />for this domain g, and tree depth of the initial layer Merkle tree commitment. add_i points to<br /><br />the address containing values common to all queries as well as to keep track of the queries<br /><br />that remain to be verified. add_f points to the address that will contain the result of adv_pipe.<br /><br />add_f - 2 * i - 2 points to the layer folding challenges alpha and add_f - 2 * i - 1 points to<br /><br />the i-th layer commitment.<br /><br />Input: #[add_i, num_q, d, g, t_d, add_f, ...]<br /><br />Output: () |
