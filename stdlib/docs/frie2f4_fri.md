
## std::crypto::fri::frie2f4
| Procedure | Description |
| ----------- | ------------- |
| preprocess | Stores the layer commitments C followed by [d_size, t_depth, a1, a0] and [0, p, e1, e0] where:<br /><br />1) d_size is the domain size divided by 4 of the domain corresponding to C.<br /><br />2) t_depth is the tree depth of the Merkle tree with commitment C.<br /><br />3) (a0, a1) is the folding challenge to create the next layer.<br /><br />4) p is the query index and (e0, e1) is the evaluation at the first layer.<br /><br />TODO: This processing function should in fact compute d_size and t_depth for each C<br /><br />starting from the original domain size. |
| verify_query_layer | Checks that, for a query with index p at layer i, the folding procedure to create layer (i + 1)<br /><br />was performed correctly. This also advances layer_ptr by 2 to point to the next query layer.<br /><br />Input:  [layer_ptr, layer_ptr, poe, p, e1, e0, layer_ptr, rem_ptr, x, x, x, x, x, x, x, x, ...]<br /><br />Output: [layer_ptr + 2, layer_ptr + 2, poe^4, f_pos, ne1, ne0, layer_ptr + 2, rem_ptr, x, x, x, x, x, x, x, x, ...]<br /><br />Cycles: 76 |
| verify_query | Verifies one FRI query.<br /><br />Input:  [poe, p, e1, e0, layer_ptr, rem_ptr, ...]<br /><br />Output: [x, x, x, x, x, x, x, x, x, x, ...]<br /><br />- poe is g^p.<br /><br />- p is a query index at the first layer.<br /><br />- (e0, e1) is an extension field elements corresponding to the value of the first layer at index p.<br /><br />- layer_ptr is the memory address of the layer data (Merkle tree root, alpha etc.) for the next<br /><br />layer.<br /><br />- rem_ptr is the memory address of the remainder codeword.<br /><br />Cycles: 40 + num_layers * 76 |
| verify | Verifies a FRI proof where the proof was generated over quadratic extension of the base field<br /><br />and layer folding was performed using folding factor 4.<br /><br />Input:  [query_start_ptr, query_end_ptr, layer_ptr, rem_ptr, g, ...]<br /><br />Output: [...]<br /><br />- query_start_ptr is a pointer to a list of tuples of the form (e0, e1, p, 0) where p is a<br /><br />query index at the first layer and (e0, e1) is an extension field elements corresponding to<br /><br />the value of the first layer at index p.<br /><br />- query_end_ptr is a pointer to the first empty memory address after the last (e0, e1, p, 0)<br /><br />tuple.<br /><br />- layer_ptr is a pointer to the first layer commitment denoted throughout the code by C.<br /><br />layer_ptr + 1 points to the first [alpha0, alpha1, t_depth, d_size] where d_size is the size<br /><br />of initial domain divided by 4, t_depth is the depth of the Merkle tree commitment to the<br /><br />first layer and (alpha0, alpha1) is the first challenge used in folding the first layer.<br /><br />Both t_depth and d_size are expected to be smaller than 2^32. Otherwise, the result of<br /><br />this procedure is undefined.<br /><br />- rem_ptr is a pointer to the first tuple of two consecutive degree 2 extension field<br /><br />elements making up the remainder codeword. This codeword can be of length either 32 or 64.<br /><br />The memory referenced above is used contiguously, as follows:<br /><br />[layer_ptr ... rem_ptr ... query_start_ptr ... query_end_ptr]<br /><br />This means for example that:<br /><br />1. rem_ptr - 1 points to the last (alpha0, alpha1, t_depth, d_size) tuple.<br /><br />2. The length of the remainder codeword is 2 * (rem_ptr - query_start_ptr).<br /><br />Cycles: for domains of size 2^n where:<br /><br />- n is even: 12 + 6 + num_queries * (40 + num_layers * 76 + 69) + 2626<br /><br />- n is odd:  12 + 6 + num_queries * (40 + num_layers * 76 + 69) + 1356 |
